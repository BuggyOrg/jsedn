// Generated by CoffeeScript 1.10.0
(function() {
  var BigInt, Char, Discard, Iterable, Keyword, List, Map, Pair, Prim, Set, StringObj, Symbol, Tag, Tagged, Vector, bigInt, char, encode, encodeHandlers, encodeJson, escapeChar, handleToken, kw, lex, parenTypes, parens, parse, read, ref, ref1, ref2, ref3, ref4, specialChars, sym, tagActions, tokenHandlers, type, typeClasses,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  type = require("./type");

  ref = require("./atoms"), Prim = ref.Prim, Symbol = ref.Symbol, Keyword = ref.Keyword, StringObj = ref.StringObj, Char = ref.Char, Discard = ref.Discard, BigInt = ref.BigInt, char = ref.char, kw = ref.kw, sym = ref.sym, bigInt = ref.bigInt;

  ref1 = require("./collections"), Iterable = ref1.Iterable, List = ref1.List, Vector = ref1.Vector, Set = ref1.Set, Pair = ref1.Pair, Map = ref1.Map;

  ref2 = require("./tags"), Tag = ref2.Tag, Tagged = ref2.Tagged, tagActions = ref2.tagActions;

  ref3 = require("./encode"), encodeHandlers = ref3.encodeHandlers, encode = ref3.encode, encodeJson = ref3.encodeJson;

  ref4 = require("./tokens"), handleToken = ref4.handleToken, tokenHandlers = ref4.tokenHandlers;

  typeClasses = {
    Map: Map,
    List: List,
    Vector: Vector,
    Set: Set,
    Discard: Discard,
    Tag: Tag,
    Tagged: Tagged,
    StringObj: StringObj
  };

  parens = '()[]{}';

  specialChars = parens + ' \t\n\r,';

  escapeChar = '\\';

  parenTypes = {
    '(': {
      closing: ')',
      "class": "List"
    },
    '[': {
      closing: ']',
      "class": "Vector"
    },
    '{': {
      closing: '}',
      "class": "Map"
    }
  };

  lex = function(string) {
    var c, col, escaping, i, in_comment, in_string, lastToken, len, line, lines, list, newToken, token;
    list = [];
    lines = [];
    line = 1;
    token = '';
    col = 1;
    lastToken = 0;
    newToken = function(name, line, col) {
      var temp;
      temp = {
        token: name,
        lineStart: line,
        colStart: col,
        lineEnd: line,
        colEnd: col
      };
      if (lastToken !== 0) {
        temp.lineStart = lastToken.lineEnd;
        temp.colStart = lastToken.colEnd;
      }
      lastToken = temp;
      return list.push(temp);
    };
    for (i = 0, len = string.length; i < len; i++) {
      c = string[i];
      if (c === "\n" || c === "\r") {
        line++;
        col = 1;
      }
      if ((typeof in_string === "undefined" || in_string === null) && c === ";" && (typeof escaping === "undefined" || escaping === null)) {
        in_comment = true;
      }
      if (in_comment) {
        if (c === "\n") {
          in_comment = void 0;
          if (token) {
            newToken(token, line, col);
            token = '';
          }
        }
        col++;
        continue;
      }
      if (c === '"' && (typeof escaping === "undefined" || escaping === null)) {
        if (typeof in_string !== "undefined" && in_string !== null) {
          newToken(new StringObj(in_string), line, col);
          in_string = void 0;
        } else {
          in_string = '';
        }
        col++;
        continue;
      }
      if (in_string != null) {
        if (c === escapeChar && (typeof escaping === "undefined" || escaping === null)) {
          escaping = true;
          col++;
          continue;
        }
        if (escaping != null) {
          escaping = void 0;
          if (c === "t" || c === "n" || c === "f" || c === "r") {
            in_string += escapeChar;
          }
        }
        in_string += c;
      } else if (indexOf.call(specialChars, c) >= 0 && (escaping == null)) {
        if (token) {
          newToken(token, line, col);
          token = '';
        }
        if (indexOf.call(parens, c) >= 0) {
          newToken(c, line, col);
        }
      } else {
        if (escaping) {
          escaping = void 0;
        } else if (c === escapeChar) {
          escaping = true;
        }
        if (token === "#_") {
          newToken(token, line, col);
          token = '';
        }
        token += c;
      }
      col++;
    }
    if (token) {
      newToken(token, line, col);
    }
    return {
      tokens: list,
      tokenLines: lines
    };
  };

  read = function(ast) {
    var read_ahead, result, token1, tokenLines, tokens;
    tokens = ast.tokens, tokenLines = ast.tokenLines;
    read_ahead = function(token, tokenIndex, expectSet) {
      var L, closeParen, handledToken, newObj, outerToken, paren, ref5, startCol, startLine, tagged;
      if (tokenIndex == null) {
        tokenIndex = 0;
      }
      if (expectSet == null) {
        expectSet = false;
      }
      if (token.token === void 0) {
        return;
      }
      if ((!(token.token instanceof StringObj)) && (paren = parenTypes[token.token])) {
        closeParen = paren.closing;
        L = [];
        startLine = token.lineStart;
        startCol = token.colStart;
        outerToken = token;
        while (true) {
          token = tokens.shift();
          if (token.token === void 0) {
            throw "unexpected end of list at line " + token.lineStart + ":" + token.colStart + "-" + token.lineEnd + ":" + token.colEnd;
          }
          tokenIndex++;
          if (token.token === paren.closing) {
            newObj = new typeClasses[expectSet ? "Set" : paren["class"]](L);
            newObj.setPos(startLine, startCol, token.lineEnd, token.lineEnd);
            return newObj;
          } else {
            L.push(read_ahead(token, tokenIndex));
          }
        }
      } else if (ref5 = token.token, indexOf.call(")]}", ref5) >= 0) {
        throw "unexpected " + token.token + " at line " + token.lineStart + ":" + token.colStart + "-" + token.lineEnd + ":" + token.colEnd;
      } else {
        handledToken = handleToken(token.token);
        if (handledToken instanceof Tag) {
          token = tokens.shift();
          tokenIndex++;
          if (token.token === void 0) {
            throw "was expecting something to follow a tag at line " + token.lineStart + ":" + token.colStart + "-" + token.lineEnd + ":" + token.colEnd;
          }
          tagged = new typeClasses.Tagged(handledToken, read_ahead(token, tokenIndex, handledToken.dn() === ""));
          tagged.setPos(token.lineStart, token.colStart, token.lineEnd, token.colEnd);
          if (handledToken.dn() === "") {
            if (tagged.obj() instanceof typeClasses.Set) {
              return tagged.obj();
            } else {
              throw "Exepected a set but did not get one at line " + token.lineStart + ":" + token.colStart + "-" + token.lineEnd + ":" + token.colEnd;
            }
          }
          if (tagged.tag().dn() === "_") {
            return new typeClasses.Discard;
          }
          if (tagActions[tagged.tag().dn()] != null) {
            return tagActions[tagged.tag().dn()].action(tagged.obj());
          }
          return tagged;
        } else {
          if (handledToken.setPos) {
            handledToken.setPos(token.lineStart, token.colStart, token.lineEnd, token.colEnd);
          }
          return handledToken;
        }
      }
    };
    token1 = tokens.shift();
    if (token1.token === void 0) {
      return void 0;
    } else {
      result = read_ahead(token1);
      if (result instanceof typeClasses.Discard) {
        return "";
      }
      return result;
    }
  };

  parse = function(string) {
    return read(lex(string));
  };

  module.exports = {
    Char: Char,
    char: char,
    Iterable: Iterable,
    Symbol: Symbol,
    sym: sym,
    Keyword: Keyword,
    kw: kw,
    BigInt: BigInt,
    bigInt: bigInt,
    List: List,
    Vector: Vector,
    Pair: Pair,
    Map: Map,
    Set: Set,
    Tag: Tag,
    Tagged: Tagged,
    setTypeClass: function(typeName, klass) {
      if (typeClasses[typeName] != null) {
        module.exports[typeName] = klass;
        return typeClasses[typeName] = klass;
      }
    },
    setTagAction: function(tag, action) {
      return tagActions[tag.dn()] = {
        tag: tag,
        action: action
      };
    },
    setTokenHandler: function(handler, pattern, action) {
      return tokenHandlers[handler] = {
        pattern: pattern,
        action: action
      };
    },
    setTokenPattern: function(handler, pattern) {
      return tokenHandlers[handler].pattern = pattern;
    },
    setTokenAction: function(handler, action) {
      return tokenHandlers[handler].action = action;
    },
    setEncodeHandler: function(handler, test, action) {
      return encodeHandlers[handler] = {
        test: test,
        action: action
      };
    },
    setEncodeTest: function(type, test) {
      return encodeHandlers[type].test = test;
    },
    setEncodeAction: function(type, action) {
      return encodeHandlers[type].action = action;
    },
    parse: parse,
    encode: encode,
    encodeJson: encodeJson,
    toJS: function(obj) {
      if ((obj != null ? obj.jsEncode : void 0) != null) {
        return obj.jsEncode();
      } else {
        return obj;
      }
    },
    atPath: require("./atPath"),
    unify: require("./unify")(parse),
    compile: require("./compile")
  };

}).call(this);
