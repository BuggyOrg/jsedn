// Generated by CoffeeScript 1.6.2
(function() {
  var Discard, Keyword, Prim, StringObj, Symbol, keywords, kw, sym, symbols, type, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  type = require("./type");

  Prim = (function() {
    function Prim(val) {
      var x;

      if (type(val) === "array") {
        this.val = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = val.length; _i < _len; _i++) {
            x = val[_i];
            if (!(x instanceof Discard)) {
              _results.push(x);
            }
          }
          return _results;
        })();
      } else {
        this.val = val;
      }
    }

    Prim.prototype.value = function() {
      return this.val;
    };

    Prim.prototype.toString = function() {
      return JSON.stringify(this.val);
    };

    return Prim;

  })();

  StringObj = (function(_super) {
    __extends(StringObj, _super);

    function StringObj() {
      _ref = StringObj.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    StringObj.prototype.toString = function() {
      return this.val;
    };

    StringObj.prototype.is = function(test) {
      return this.val === test;
    };

    return StringObj;

  })(Prim);

  Discard = (function() {
    function Discard() {}

    return Discard;

  })();

  Symbol = (function(_super) {
    __extends(Symbol, _super);

    function Symbol() {
      var args, parts;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      switch (args.length) {
        case 1:
          if (args[0] === "/") {
            this.ns = null;
            this.name = "/";
          } else {
            parts = args[0].split("/");
            if (parts.length === 1) {
              this.ns = null;
              this.name = parts[0];
            } else if (parts.length === 2) {
              this.ns = parts[0];
              this.name = parts[1];
            } else {
              throw "Can not have more than 1 forward slash in a symbol";
            }
          }
          break;
        case 2:
          this.ns = args[0];
          this.name = args[1];
      }
      if (this.name.length === 0) {
        throw "Length of Symbol name can not be empty";
      }
      if (/^[0-9]/.test(this.name[0])) {
        throw "Symbol cannot start with a number";
      }
      this.val = "" + (this.ns ? "" + this.ns + "/" : "") + this.name;
    }

    Symbol.prototype.toString = function() {
      return this.val;
    };

    Symbol.prototype.ednEncode = function() {
      return this.val;
    };

    Symbol.prototype.jsEncode = function() {
      return this.val;
    };

    Symbol.prototype.jsonEncode = function() {
      return {
        Symbol: this.val
      };
    };

    return Symbol;

  })(Prim);

  Keyword = (function(_super) {
    __extends(Keyword, _super);

    function Keyword() {
      Keyword.__super__.constructor.apply(this, arguments);
      if (this.val[0] !== ":") {
        throw "keyword must start with a :";
      }
    }

    Keyword.prototype.jsonEncode = function() {
      return {
        Keyword: this.val
      };
    };

    return Keyword;

  })(Symbol);

  keywords = {};

  kw = function(word) {
    if (keywords[word] == null) {
      keywords[word] = new Keyword(word);
    }
    return keywords[word];
  };

  symbols = {};

  sym = function(val) {
    if (symbols[val] == null) {
      symbols[val] = new Symbol(val);
    }
    return symbols[val];
  };

  module.exports = {
    Prim: Prim,
    Symbol: Symbol,
    Keyword: Keyword,
    StringObj: StringObj,
    Discard: Discard,
    kw: kw,
    sym: sym
  };

}).call(this);
